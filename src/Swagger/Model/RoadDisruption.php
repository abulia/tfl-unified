<?php
/**
 * RoadDisruption
 *
 * PHP version 5
 *
 * @category Class
 * @package  Abulia\TflUnified\Swagger
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Transport for London Unified API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Abulia\TflUnified\Swagger\Model;

use \ArrayAccess;
use Illuminate\Contracts\Support\Jsonable;

/**
 * RoadDisruption Class Doc Comment
 *
 * @category    Class
 * @package     Abulia\TflUnified\Swagger
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class RoadDisruption implements ArrayAccess, Jsonable
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'RoadDisruption';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'category' => 'string',
        'comments' => 'string',
        'corridor_ids' => 'string[]',
        'current_update' => 'string',
        'current_update_date_time' => '\DateTime',
        'end_date_time' => '\DateTime',
        'geography' => '\Abulia\TflUnified\Swagger\Model\DbGeography',
        'geometry' => '\Abulia\TflUnified\Swagger\Model\DbGeography',
        'has_closures' => 'bool',
        'id' => 'string',
        'is_provisional' => 'bool',
        'last_modified_time' => '\DateTime',
        'level_of_interest' => 'string',
        'link_text' => 'string',
        'link_url' => 'string',
        'location' => 'string',
        'ordinal' => 'int',
        'point' => 'string',
        'publish_end_date' => '\DateTime',
        'publish_start_date' => '\DateTime',
        'recurring_schedules' => '\Abulia\TflUnified\Swagger\Model\RoadDisruptionSchedule[]',
        'road_disruption_impact_areas' => '\Abulia\TflUnified\Swagger\Model\RoadDisruptionImpactArea[]',
        'road_disruption_lines' => '\Abulia\TflUnified\Swagger\Model\RoadDisruptionLine[]',
        'road_project' => '\Abulia\TflUnified\Swagger\Model\RoadProject',
        'severity' => 'string',
        'start_date_time' => '\DateTime',
        'status' => 'string',
        'streets' => '\Abulia\TflUnified\Swagger\Model\Street[]',
        'sub_category' => 'string',
        'time_frame' => 'string',
        'url' => 'string'
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'category' => 'category',
        'comments' => 'comments',
        'corridor_ids' => 'corridorIds',
        'current_update' => 'currentUpdate',
        'current_update_date_time' => 'currentUpdateDateTime',
        'end_date_time' => 'endDateTime',
        'geography' => 'geography',
        'geometry' => 'geometry',
        'has_closures' => 'hasClosures',
        'id' => 'id',
        'is_provisional' => 'isProvisional',
        'last_modified_time' => 'lastModifiedTime',
        'level_of_interest' => 'levelOfInterest',
        'link_text' => 'linkText',
        'link_url' => 'linkUrl',
        'location' => 'location',
        'ordinal' => 'ordinal',
        'point' => 'point',
        'publish_end_date' => 'publishEndDate',
        'publish_start_date' => 'publishStartDate',
        'recurring_schedules' => 'recurringSchedules',
        'road_disruption_impact_areas' => 'roadDisruptionImpactAreas',
        'road_disruption_lines' => 'roadDisruptionLines',
        'road_project' => 'roadProject',
        'severity' => 'severity',
        'start_date_time' => 'startDateTime',
        'status' => 'status',
        'streets' => 'streets',
        'sub_category' => 'subCategory',
        'time_frame' => 'timeFrame',
        'url' => 'url'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'category' => 'setCategory',
        'comments' => 'setComments',
        'corridor_ids' => 'setCorridorIds',
        'current_update' => 'setCurrentUpdate',
        'current_update_date_time' => 'setCurrentUpdateDateTime',
        'end_date_time' => 'setEndDateTime',
        'geography' => 'setGeography',
        'geometry' => 'setGeometry',
        'has_closures' => 'setHasClosures',
        'id' => 'setId',
        'is_provisional' => 'setIsProvisional',
        'last_modified_time' => 'setLastModifiedTime',
        'level_of_interest' => 'setLevelOfInterest',
        'link_text' => 'setLinkText',
        'link_url' => 'setLinkUrl',
        'location' => 'setLocation',
        'ordinal' => 'setOrdinal',
        'point' => 'setPoint',
        'publish_end_date' => 'setPublishEndDate',
        'publish_start_date' => 'setPublishStartDate',
        'recurring_schedules' => 'setRecurringSchedules',
        'road_disruption_impact_areas' => 'setRoadDisruptionImpactAreas',
        'road_disruption_lines' => 'setRoadDisruptionLines',
        'road_project' => 'setRoadProject',
        'severity' => 'setSeverity',
        'start_date_time' => 'setStartDateTime',
        'status' => 'setStatus',
        'streets' => 'setStreets',
        'sub_category' => 'setSubCategory',
        'time_frame' => 'setTimeFrame',
        'url' => 'setUrl'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'category' => 'getCategory',
        'comments' => 'getComments',
        'corridor_ids' => 'getCorridorIds',
        'current_update' => 'getCurrentUpdate',
        'current_update_date_time' => 'getCurrentUpdateDateTime',
        'end_date_time' => 'getEndDateTime',
        'geography' => 'getGeography',
        'geometry' => 'getGeometry',
        'has_closures' => 'getHasClosures',
        'id' => 'getId',
        'is_provisional' => 'getIsProvisional',
        'last_modified_time' => 'getLastModifiedTime',
        'level_of_interest' => 'getLevelOfInterest',
        'link_text' => 'getLinkText',
        'link_url' => 'getLinkUrl',
        'location' => 'getLocation',
        'ordinal' => 'getOrdinal',
        'point' => 'getPoint',
        'publish_end_date' => 'getPublishEndDate',
        'publish_start_date' => 'getPublishStartDate',
        'recurring_schedules' => 'getRecurringSchedules',
        'road_disruption_impact_areas' => 'getRoadDisruptionImpactAreas',
        'road_disruption_lines' => 'getRoadDisruptionLines',
        'road_project' => 'getRoadProject',
        'severity' => 'getSeverity',
        'start_date_time' => 'getStartDateTime',
        'status' => 'getStatus',
        'streets' => 'getStreets',
        'sub_category' => 'getSubCategory',
        'time_frame' => 'getTimeFrame',
        'url' => 'getUrl'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    

    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['category'] = isset($data['category']) ? $data['category'] : null;
        $this->container['comments'] = isset($data['comments']) ? $data['comments'] : null;
        $this->container['corridor_ids'] = isset($data['corridor_ids']) ? $data['corridor_ids'] : null;
        $this->container['current_update'] = isset($data['current_update']) ? $data['current_update'] : null;
        $this->container['current_update_date_time'] = isset($data['current_update_date_time']) ? $data['current_update_date_time'] : null;
        $this->container['end_date_time'] = isset($data['end_date_time']) ? $data['end_date_time'] : null;
        $this->container['geography'] = isset($data['geography']) ? $data['geography'] : null;
        $this->container['geometry'] = isset($data['geometry']) ? $data['geometry'] : null;
        $this->container['has_closures'] = isset($data['has_closures']) ? $data['has_closures'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['is_provisional'] = isset($data['is_provisional']) ? $data['is_provisional'] : null;
        $this->container['last_modified_time'] = isset($data['last_modified_time']) ? $data['last_modified_time'] : null;
        $this->container['level_of_interest'] = isset($data['level_of_interest']) ? $data['level_of_interest'] : null;
        $this->container['link_text'] = isset($data['link_text']) ? $data['link_text'] : null;
        $this->container['link_url'] = isset($data['link_url']) ? $data['link_url'] : null;
        $this->container['location'] = isset($data['location']) ? $data['location'] : null;
        $this->container['ordinal'] = isset($data['ordinal']) ? $data['ordinal'] : null;
        $this->container['point'] = isset($data['point']) ? $data['point'] : null;
        $this->container['publish_end_date'] = isset($data['publish_end_date']) ? $data['publish_end_date'] : null;
        $this->container['publish_start_date'] = isset($data['publish_start_date']) ? $data['publish_start_date'] : null;
        $this->container['recurring_schedules'] = isset($data['recurring_schedules']) ? $data['recurring_schedules'] : null;
        $this->container['road_disruption_impact_areas'] = isset($data['road_disruption_impact_areas']) ? $data['road_disruption_impact_areas'] : null;
        $this->container['road_disruption_lines'] = isset($data['road_disruption_lines']) ? $data['road_disruption_lines'] : null;
        $this->container['road_project'] = isset($data['road_project']) ? $data['road_project'] : null;
        $this->container['severity'] = isset($data['severity']) ? $data['severity'] : null;
        $this->container['start_date_time'] = isset($data['start_date_time']) ? $data['start_date_time'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['streets'] = isset($data['streets']) ? $data['streets'] : null;
        $this->container['sub_category'] = isset($data['sub_category']) ? $data['sub_category'] : null;
        $this->container['time_frame'] = isset($data['time_frame']) ? $data['time_frame'] : null;
        $this->container['url'] = isset($data['url']) ? $data['url'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        return true;
    }


    /**
     * Gets category
     * @return string
     */
    public function getCategory()
    {
        return $this->container['category'];
    }

    /**
     * Sets category
     * @param string $category Describes the nature of disruption e.g. Traffic Incidents, Works
     * @return $this
     */
    public function setCategory($category)
    {
        $this->container['category'] = $category;

        return $this;
    }

    /**
     * Gets comments
     * @return string
     */
    public function getComments()
    {
        return $this->container['comments'];
    }

    /**
     * Sets comments
     * @param string $comments Full text of comments describing the disruption, including details of any road closures and diversions, where appropriate.
     * @return $this
     */
    public function setComments($comments)
    {
        $this->container['comments'] = $comments;

        return $this;
    }

    /**
     * Gets corridor_ids
     * @return string[]
     */
    public function getCorridorIds()
    {
        return $this->container['corridor_ids'];
    }

    /**
     * Sets corridor_ids
     * @param string[] $corridor_ids The Ids of affected corridors, if any.
     * @return $this
     */
    public function setCorridorIds($corridor_ids)
    {
        $this->container['corridor_ids'] = $corridor_ids;

        return $this;
    }

    /**
     * Gets current_update
     * @return string
     */
    public function getCurrentUpdate()
    {
        return $this->container['current_update'];
    }

    /**
     * Sets current_update
     * @param string $current_update Text of the most recent update from the LSTCC on the state of the               disruption, including the current traffic impact and any advice to               road users.
     * @return $this
     */
    public function setCurrentUpdate($current_update)
    {
        $this->container['current_update'] = $current_update;

        return $this;
    }

    /**
     * Gets current_update_date_time
     * @return \DateTime
     */
    public function getCurrentUpdateDateTime()
    {
        return $this->container['current_update_date_time'];
    }

    /**
     * Sets current_update_date_time
     * @param \DateTime $current_update_date_time The time when the last CurrentUpdate description was recorded,               or null if no CurrentUpdate has been applied.
     * @return $this
     */
    public function setCurrentUpdateDateTime($current_update_date_time)
    {
        $this->container['current_update_date_time'] = $current_update_date_time;

        return $this;
    }

    /**
     * Gets end_date_time
     * @return \DateTime
     */
    public function getEndDateTime()
    {
        return $this->container['end_date_time'];
    }

    /**
     * Sets end_date_time
     * @param \DateTime $end_date_time The date and time on which the disruption ended. For planned disruptions, this date will have a valid value. For unplanned               disruptions in progress, this field will be omitted.
     * @return $this
     */
    public function setEndDateTime($end_date_time)
    {
        $this->container['end_date_time'] = $end_date_time;

        return $this;
    }

    /**
     * Gets geography
     * @return \Abulia\TflUnified\Swagger\Model\DbGeography
     */
    public function getGeography()
    {
        return $this->container['geography'];
    }

    /**
     * Sets geography
     * @param \Abulia\TflUnified\Swagger\Model\DbGeography $geography Geography version of Point for output as GeoJSON.              Can not use Geometry in a consistent way as non-TIMS disruptions do not have a polygon
     * @return $this
     */
    public function setGeography($geography)
    {
        $this->container['geography'] = $geography;

        return $this;
    }

    /**
     * Gets geometry
     * @return \Abulia\TflUnified\Swagger\Model\DbGeography
     */
    public function getGeometry()
    {
        return $this->container['geometry'];
    }

    /**
     * Sets geometry
     * @param \Abulia\TflUnified\Swagger\Model\DbGeography $geometry GeoJSON formatted latitude/longitude (WGS84) pairs forming an enclosed polyline or polygon. The polygon will only be included where affected streets information              is not available for the disruption, would be inappropriate (e.g. a very large number of streets), or is centred on an area without streets (e.g. a football stadium).
     * @return $this
     */
    public function setGeometry($geometry)
    {
        $this->container['geometry'] = $geometry;

        return $this;
    }

    /**
     * Gets has_closures
     * @return bool
     */
    public function getHasClosures()
    {
        return $this->container['has_closures'];
    }

    /**
     * Sets has_closures
     * @param bool $has_closures True if any of the affected Streets have a \"Full Closure\" status, false otherwise. A RoadDisruption that has HasClosures is considered a               Severe or Serious disruption for severity filtering purposes.
     * @return $this
     */
    public function setHasClosures($has_closures)
    {
        $this->container['has_closures'] = $has_closures;

        return $this;
    }

    /**
     * Gets id
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     * @param string $id Unique identifier for the road disruption
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets is_provisional
     * @return bool
     */
    public function getIsProvisional()
    {
        return $this->container['is_provisional'];
    }

    /**
     * Sets is_provisional
     * @param bool $is_provisional True if the disruption is planned on a future date that is open to change
     * @return $this
     */
    public function setIsProvisional($is_provisional)
    {
        $this->container['is_provisional'] = $is_provisional;

        return $this;
    }

    /**
     * Gets last_modified_time
     * @return \DateTime
     */
    public function getLastModifiedTime()
    {
        return $this->container['last_modified_time'];
    }

    /**
     * Sets last_modified_time
     * @param \DateTime $last_modified_time The date and time on which the disruption was last modified in the system. This information can reliably be used by a developer to quickly              compare two instances of the same disruption to determine if it has been changed.
     * @return $this
     */
    public function setLastModifiedTime($last_modified_time)
    {
        $this->container['last_modified_time'] = $last_modified_time;

        return $this;
    }

    /**
     * Gets level_of_interest
     * @return string
     */
    public function getLevelOfInterest()
    {
        return $this->container['level_of_interest'];
    }

    /**
     * Sets level_of_interest
     * @param string $level_of_interest This describes the level of potential impact on traffic operations of the disruption.               High = e.g. a one-off disruption on a major or high profile route which will require a high level of operational attention               Medium = This is the default value               Low = e.g. a frequently occurring disruption which is well known
     * @return $this
     */
    public function setLevelOfInterest($level_of_interest)
    {
        $this->container['level_of_interest'] = $level_of_interest;

        return $this;
    }

    /**
     * Gets link_text
     * @return string
     */
    public function getLinkText()
    {
        return $this->container['link_text'];
    }

    /**
     * Sets link_text
     * @param string $link_text The text of any associated link
     * @return $this
     */
    public function setLinkText($link_text)
    {
        $this->container['link_text'] = $link_text;

        return $this;
    }

    /**
     * Gets link_url
     * @return string
     */
    public function getLinkUrl()
    {
        return $this->container['link_url'];
    }

    /**
     * Sets link_url
     * @param string $link_url The url of any associated link
     * @return $this
     */
    public function setLinkUrl($link_url)
    {
        $this->container['link_url'] = $link_url;

        return $this;
    }

    /**
     * Gets location
     * @return string
     */
    public function getLocation()
    {
        return $this->container['location'];
    }

    /**
     * Sets location
     * @param string $location Main road name / number (borough) or preset area name where the disruption is located. This might be useful for a map popup where space is limited.
     * @return $this
     */
    public function setLocation($location)
    {
        $this->container['location'] = $location;

        return $this;
    }

    /**
     * Gets ordinal
     * @return int
     */
    public function getOrdinal()
    {
        return $this->container['ordinal'];
    }

    /**
     * Sets ordinal
     * @param int $ordinal An ordinal of the disruption based on severity, level of interest and corridor.
     * @return $this
     */
    public function setOrdinal($ordinal)
    {
        $this->container['ordinal'] = $ordinal;

        return $this;
    }

    /**
     * Gets point
     * @return string
     */
    public function getPoint()
    {
        return $this->container['point'];
    }

    /**
     * Sets point
     * @param string $point Latitude and longitude (WGS84) of the centroid of the disruption, stored in a geoJSON-formatted string.
     * @return $this
     */
    public function setPoint($point)
    {
        $this->container['point'] = $point;

        return $this;
    }

    /**
     * Gets publish_end_date
     * @return \DateTime
     */
    public function getPublishEndDate()
    {
        return $this->container['publish_end_date'];
    }

    /**
     * Sets publish_end_date
     * @param \DateTime $publish_end_date
     * @return $this
     */
    public function setPublishEndDate($publish_end_date)
    {
        $this->container['publish_end_date'] = $publish_end_date;

        return $this;
    }

    /**
     * Gets publish_start_date
     * @return \DateTime
     */
    public function getPublishStartDate()
    {
        return $this->container['publish_start_date'];
    }

    /**
     * Sets publish_start_date
     * @param \DateTime $publish_start_date TDM Additional properties
     * @return $this
     */
    public function setPublishStartDate($publish_start_date)
    {
        $this->container['publish_start_date'] = $publish_start_date;

        return $this;
    }

    /**
     * Gets recurring_schedules
     * @return \Abulia\TflUnified\Swagger\Model\RoadDisruptionSchedule[]
     */
    public function getRecurringSchedules()
    {
        return $this->container['recurring_schedules'];
    }

    /**
     * Sets recurring_schedules
     * @param \Abulia\TflUnified\Swagger\Model\RoadDisruptionSchedule[] $recurring_schedules
     * @return $this
     */
    public function setRecurringSchedules($recurring_schedules)
    {
        $this->container['recurring_schedules'] = $recurring_schedules;

        return $this;
    }

    /**
     * Gets road_disruption_impact_areas
     * @return \Abulia\TflUnified\Swagger\Model\RoadDisruptionImpactArea[]
     */
    public function getRoadDisruptionImpactAreas()
    {
        return $this->container['road_disruption_impact_areas'];
    }

    /**
     * Sets road_disruption_impact_areas
     * @param \Abulia\TflUnified\Swagger\Model\RoadDisruptionImpactArea[] $road_disruption_impact_areas
     * @return $this
     */
    public function setRoadDisruptionImpactAreas($road_disruption_impact_areas)
    {
        $this->container['road_disruption_impact_areas'] = $road_disruption_impact_areas;

        return $this;
    }

    /**
     * Gets road_disruption_lines
     * @return \Abulia\TflUnified\Swagger\Model\RoadDisruptionLine[]
     */
    public function getRoadDisruptionLines()
    {
        return $this->container['road_disruption_lines'];
    }

    /**
     * Sets road_disruption_lines
     * @param \Abulia\TflUnified\Swagger\Model\RoadDisruptionLine[] $road_disruption_lines
     * @return $this
     */
    public function setRoadDisruptionLines($road_disruption_lines)
    {
        $this->container['road_disruption_lines'] = $road_disruption_lines;

        return $this;
    }

    /**
     * Gets road_project
     * @return \Abulia\TflUnified\Swagger\Model\RoadProject
     */
    public function getRoadProject()
    {
        return $this->container['road_project'];
    }

    /**
     * Sets road_project
     * @param \Abulia\TflUnified\Swagger\Model\RoadProject $road_project Any associated road project
     * @return $this
     */
    public function setRoadProject($road_project)
    {
        $this->container['road_project'] = $road_project;

        return $this;
    }

    /**
     * Gets severity
     * @return string
     */
    public function getSeverity()
    {
        return $this->container['severity'];
    }

    /**
     * Sets severity
     * @param string $severity A description of the severity of the disruption.
     * @return $this
     */
    public function setSeverity($severity)
    {
        $this->container['severity'] = $severity;

        return $this;
    }

    /**
     * Gets start_date_time
     * @return \DateTime
     */
    public function getStartDateTime()
    {
        return $this->container['start_date_time'];
    }

    /**
     * Sets start_date_time
     * @param \DateTime $start_date_time The date and time which the disruption started. For a planned disruption (i.e. planned road works) this date will be in the future.              For unplanned disruptions, this will default to the date on which the disruption was first recorded, but may be adjusted by the operator.
     * @return $this
     */
    public function setStartDateTime($start_date_time)
    {
        $this->container['start_date_time'] = $start_date_time;

        return $this;
    }

    /**
     * Gets status
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     * @param string $status This describes the status of the disruption.                Active = currently in progress               Active Long Term = currently in progress and long term              Scheduled = scheduled to start within the next 180 days              Recurring Works = planned maintenance works that follow a regular routine or pattern and whose next occurrence is to start within the next 180 days.              Recently Cleared = recently cleared in the last 24 hours              Note that the status of Scheduled or Recurring Works disruptions will change to Active when they start, and will change status again when they end.
     * @return $this
     */
    public function setStatus($status)
    {
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets streets
     * @return \Abulia\TflUnified\Swagger\Model\Street[]
     */
    public function getStreets()
    {
        return $this->container['streets'];
    }

    /**
     * Sets streets
     * @param \Abulia\TflUnified\Swagger\Model\Street[] $streets A collection of zero or more streets affected by the disruption.
     * @return $this
     */
    public function setStreets($streets)
    {
        $this->container['streets'] = $streets;

        return $this;
    }

    /**
     * Gets sub_category
     * @return string
     */
    public function getSubCategory()
    {
        return $this->container['sub_category'];
    }

    /**
     * Sets sub_category
     * @param string $sub_category Describes the sub-category of disruption e.g. Collapsed Manhole, Abnormal Load
     * @return $this
     */
    public function setSubCategory($sub_category)
    {
        $this->container['sub_category'] = $sub_category;

        return $this;
    }

    /**
     * Gets time_frame
     * @return string
     */
    public function getTimeFrame()
    {
        return $this->container['time_frame'];
    }

    /**
     * Sets time_frame
     * @param string $time_frame
     * @return $this
     */
    public function setTimeFrame($time_frame)
    {
        $this->container['time_frame'] = $time_frame;

        return $this;
    }

    /**
     * Gets url
     * @return string
     */
    public function getUrl()
    {
        return $this->container['url'];
    }

    /**
     * Sets url
     * @param string $url URL to retrieve this road disruption
     * @return $this
     */
    public function setUrl($url)
    {
        $this->container['url'] = $url;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Abulia\TflUnified\Swagger\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Abulia\TflUnified\Swagger\ObjectSerializer::sanitizeForSerialization($this));
    }

    /**
     * To allow implict conversion to JSON by Laravel.
     */
    public function toJson($options = 0)
    {
        return $this->__toString();
    }

    /**
     * For convenient property based access.
     */
    public function __get($name)
    {
        if (isset(static::$getters[$name])) {
            return $this->{static::$getters[$name]}();
        }
        return null;
    }
}


